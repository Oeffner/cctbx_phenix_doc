{% extends "cctbx/header.html" %}

{% load static %}

{% block content %}

<div class="col-sm-9 main">
  <!-- DO NOT EDIT ANYTHING ABOVE!!!! -->
  <!----------------------- EDIT START ---------------------------->

  <h2><center>HKLviewer</center></h2>

  <p class="lead mt-4">
    Learn how to visualize the reflections of your diffraction dataset.<br>
    Author: Robert D. Oeffner
  </p>

  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Introduction</h3>

  <p>
    The HKLviewer lets you inspect diffraction data sets to understand possible issues that may hamper
    structure solution.
    The HKlviewer is available from a CCTBX installation. In the command line, type
    <code>cctbx.HKLviewer</code> in a system shell. Alternatively double click the file icon of
    <code>CCTBX\build\bin\cctbx.HKLviewer </code>in a file manager. From the command line, add the name of a reflection
    file to open it immediately.
  </p>

  <p>
    If you find HKLviewer useful in your work please cite
    <a href="https://phenix-online.org/phenixwebsite_static/mainsite/files/newsletter/CCN_2021_01.pdf#page=15">Computational Crystallography Newsletter (2021). 12, 15-25</a> in your publication.
  </p>

  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Look and Feel</h3>
  <p>
    The HKLviewer consists of a 3-dimensional graphics rendering window together with the HKLviewer controls. The HKLviewer
    controls consists of two tabs, "Quick View" and "Details", together with a text area for information being emitted
    during usage. The HKLviewer controls can be torn off and floated from the main window or docked in a different
    orientation with the mouse. The layout and the settings customised by the user will be persisted next time the HKLviewer
    is started.

  </p>
  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/LookFeel.png' %}">
  <h5>Background colour</h5>
<p>
  The background colour of the graphics rendering window can be adjusted from the background colour menu item from the
  File menu.
</p>
  <h5>HKLviewer Settings dialog</h5>
  The "HKLviewer Settings" dialog that is invoked from the "File|Settings" (or Preferences) menu item lets you adjust
  the mouse speed and the font size for the QtGui as well as for the legends and tooltips displayed for the 3D view (Browser).
  Tooltips can be set to only pop up when a reflection is clicked.


  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Opening a file</h3>

  <p>
    Reflection files of the type .mtz., .sca, .hkl, .cif can be openend from the "File | Open" menu item. The last
    three file types are text files and wil open correctly as long as they contain space group information.
    Alternatively the filename can be specified as an argument on the command line where the CCTBX environment has been invoked:
  </p>

<pre class="CodeGreen"><code>cctbx.HKLviewer 3EIL.mtz</code></pre>

  <p>
    The types of reflection files that can be loaded are .mtz, .hkl, .cif and .sca files assuming the space
    group and unit cell dimension is present in the file.
  </p>

  <!----------------------------------------------------------------------------->
  <h3 class="mt-4">Predefined buttons</h3>
  <p>
    The "Quick View" tab contains several predefined radio buttons such as "Show Amplitudes",
    "Show plane of Intensities with constant H", "F/SigF", "I/SigI>=2", "E-values", "Merged Intensities" and
    "Multiplicities". Those buttons provide a quick way to the typical ways of displaying reflections from a
    loaded reflection file.
  </p>
  <img style="max-width: 80%;" src="{% static 'cctbx/img/hklviewer/presetbuttons.png' %}">
  <p />
  Depending on what datasets are present not all of those buttons will show up.
  The "I/SigI>=2", "Merged Intensities" and "Multiplicities" will only be available if there is an intensity
  dataset in the file.
  <p />

  <!----------------------------------------------------------------------------->
  <h5 class="mt-4">How to display amplitudes or intensities</h5>
  <p>
    The first dataset of type "Intensities" in the loaded file can be displayed by pressing the "Show Intensities" button.
    HKLviewer first looks for a dataset labelled "I,SIGI" and associates that
    with the "Show Intensities" button. Failing that, it will look for a dataset of type "Intensity" and use that instead.
    If such a dataset is still not found the button will not be shown. The same applies to the "Show Amplitudes button"
    where it is looking for the dataset "FOBS,SIGFOBS" or a dataset of type "Amplitude".
  </p>

  <h5 class="mt-4">How to display slices of intensities or amplitudes</h5>
  <p>
    Slices of reflections at constant H, K or L can be displayed by pressing one of the "Show plane of intensities"
    or "Show plane of amplitudes" buttons and then selecting H, K or L-axis from the drop-down list.
    HKLviewer will expand intensities or amplitudes data to P1 and Friedel mates. The slice of reflections in reciprocal
    space is obtained by imposing two clip planes perpendicular to the Z-axis on both sides of the origin. Only reflections
    in between the clip planes are visible. HKLviewer then orients the reciprocal space so in case of showing a plane of
    reflections with constant L, the real space vector associated with the L axis is normal to the clip planes, i.e. parallel
    to the Z-axis. The plane of visible reflections is indicated with the equation shown in the bottom of the graphics window.
    Plus/Minus bottons are available for stepping through the layers of reflections. The clip planes are always oriented
    perpendicular to the Z-axis. Arbitrary
    <a href="#how-to-slice-reflections-with-arbitrarily-oriented-clip-planes">orientation of clip planes relative to the displayed reflections</a>
    is also possible.
  </p>
  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/reflection_slice_eqn.png' %}">

  <p class="mt-3">
    Which dataset a button is associated with can be discovered from the tooltip by hovering the mouse over
    the button in question.
  </p>
  <!----------------------------------------------------------------------------->

  <h5 class="mt-4">I/SigI>=2, F/SigF, E-values</h5>
  <p>
    For a dataset containing intensity data or amplitude data new datasets can be calculated on the fly containing the
    data values divided by their asssociated sigma values, i.e. I/SigI>=2 or F/SigF. These are common indicators of the
    strength of the data. Reflections with I/SigI>=2 is a typical criterion for what constitutes reliable data values.
    This can be changed to a different value on the Binning tab on the Details tab once the "I/SigI>=2" data
    is displayed.
  <p />
  <p>
    E-values i.e. normalised amplitudes can also be calculated on the fly with a button press. E-values are computed with to
    the
    <a href="https://cctbx.github.io/cctbx/cctbx.miller.html#cctbx.miller.array.normalize">normalize function</a>
    in the CCTBX.
    This rescales amplitudes by inverting B-factor and scattering factor attenuation
    to make all reflections regardless of resolution shell appear on average to have the same strength.
    Anisotropic or TNCS correction is not applied and currently the sigmas are not converted.
<p />
<a name="merged_Intensities"></a>
  <h5 class="mt-4">Merged Intensities and Multiplicities</h5>
  Given an unmerged dataset of intensities, the "Merged Intensities" button will merge the symmetry-related
  reflections and average over anomalous data, i.e. put reflections into just one asymmetric unit wedge if that is not
  already the case. The "Multiplicities" button will create a dataset of integers counting
  how many symmetry related reflections was used to produce a reflection in the merged array. These two buttons
  are using the  <a href="https://cctbx.github.io/cctbx/cctbx.miller.html#cctbx.miller.array.merge_equivalents">
  merge_equivalents function<a /> in CCTBX. An example using these buttons is given as a
  <a href="../tuto_hklviewer/#inspecting_unmerged_dataset">tutorial here</a>.

  </p>
  <!----------------------------------------------------------------------------->

  <h4 class="mt-4">User defined buttons</h4>
  <p>
    It is also possible to add your own
    customised buttons to the Quick View tab. Customised buttons are defined in the file
    .hkl_viewer_buttons.py which is created in the users home directory the very first time
    the user runs HKLviewer. It will be loaded next time the user starts HKLviewer again.
    It contains a python list of tuples where each tuple specifies a button. A tuple consists
    of a unique id, a button label
    and a <a href="#further-api-details">PHIL</a> parameter string defining how the HKLviewer should present a particular
    data set. The PHIL parameters specifies what type of data set (amplitudes, intensities, etc)
    should be displayed as well as how it should be displayed. The PHIL parameters may also
    define displaying an additional data set that is yet to be calculated on the fly such as I/SigI. Read
    <a href="#how-to-make-a-new-dataset">here on how to create new a dataset</a>.
  </p>

  <!----------------------------------------------------------------------------->

  <h5 class="mt-4">Creating a new button</h5>

  To create a new button amounts to display a dataset in a particular manner, extract the PHIL parameters defining
  how reflections are displayed and then insert the PHIL parameters into the users's .hkl_viewer_buttons.py file.
  To create a button that expands amplitude data to Friedel pairs simply display the amplitude dataset and then expand it to
  Friedel pairs as described in <a href="#expand_reflections">How to expand reflections</a>.

  <!----------------------------------------------------------------------------->
  <a name="get_PHIL_params"></a>
  <h5 class="mt-4">Get PHIL parameters for a button</h5>
  <p>
    The PHIL parameters defining the current view, say expansion to Friedel pairs of amplitude data,
    is obtained from the
    "HKLviewer Settings" dialog that is invoked from the "File|Settings" (or Preferences) menu item.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/show_PHIL.png' %}">

  <p>
    On that dialog press the "Show PHIL" button (encircled with a green pen) to display the current
    non-default PHIL parameter values.
    The PHIL parameter values will appear in the text output field in the bottom left part of the
    HKLviewer controls (encircled with a blue pen) on the figure above.
  </p>

  <p>
    For defining the customised button that displays amplitude data expanded to Friedel pairs
    copy and paste these PHIL parameters into the .hkl_viewer_buttons.py file as shown below.
    Encircled in blue is the location for where to place the string of PHIL parameters
    for expanding amplitude reflections in the python list of tuples that defines the users buttons.<br />

    The PHIL parameter string must be enclosed with triple quotation marks to allow it spanning multiple lines.
    A unique stringID, say "FriedelBtn" as wells as a text string to display next to the button,
    say "Show Friedel pairs of Amplitudes", must also be provided.
    <a name="hkl_viewer_buttons_py_file"></a>
    These two tuple elements come before the PHIL parameters string.
  </p>


  <img style="max-width: 80%;" src="{% static 'cctbx/img/hklviewer/user_preset_btn.png' %}">

  <p>
    When the HKLviewer is restarted with this file present as .hkl_viewer_buttons.py in the user's HOME directory
    buttons defined in this file will appear on the "Quick View" tab encircled with a green pen as
    illustrated below. 
  </p>

  <img style="max-width: 70%;" src="{% static 'cctbx/img/hklviewer/user_preset_btn_loaded.png' %}">
  <p>
    These buttons provide a quick way of displaying data in a particular way the user only needs to specify once.
  </p>


  <h3 class="mt-4">How to display other reflection datasets</h3>

  <p>
    Data sets other than what are available from the Quick View tab can be
    displayed from the details tab by double-clicking the row with
    the corresponding label in the upper left table.
  </p>

  <!----------------------------------------------------------------------------->

  <h5 class="mt-4">How to display sigmas</h5>

  <p>
    If a dataset contains sigmas associated to amplitudes or intensities, say it is labelled as
    "F,SIGF", then these can be displayed from the details tab with a right click on the
    respective row in the upper-left table. A
    menu will appear where the second item will be "Display sigmas of F,SIGF". Selecting that item will display
    the data in the viewer with the colour mapping and the size of the reflection spheres now being mapped
    according to sigma values in the dataset.
  </p>


  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Xtriage, Xtricorder and XDSGUI Integration</h3>

  <a name="Xtriage"></a>
  <h5 class="mt-4">Xtriage</h5>
  Xtriage is also a part of the CCTBX and Phenix. An amplitude or intensity dataset that is displayed in the
  HKLviewer can be processed with Xtriage by clicking on the "Xtriage" button on top on the "Quick View" tab
  of the HKLviewer controls. Once it has finished a log file from the Xtriage run will be present in the bottom
  of the HKLviewer controls as an additional tab.

  If the dataset is likely to be twinned Xtriage will emit a list of possible twin operators which the HKLviewer
  then makes accessible as buttons below on the "Quick View" tab as well as on the Vectors tab found on the
  Details tab. The twin operator which Xtriage computes to have the lowest R-obs value is usually the most interesting.
  It is found in the list of twin operators in the Xtriage tab and matches one of the rotation operators on the
  Vectors tab found on the Details tab.
  A tutorial on how to inspect a twin law is given as a
  <a href="../tuto_hklviewer/#inspecting_a_twin_law">tutorial</a>.
  <br />
  Xtriage will also detect TNCS modulation with a patterson peak height larger than
  0.1 of the origin peak height. If present, buttons will be available allowing inspection of the modulation
  from amplitudes or intensities converted into E-values. If the modulation is weak it may not be
  visible to the naked eye.
  Below is a snapshot of the buttons available (red bubble) if there is twinning and TNCS in the dataset
  analysed by Xtriage.
  <br />
  <br />

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/XtricorderXtriagebuttons.png' %}">

  <a name="Xtricorder"></a>
  <h5 class="mt-4">Xtricorder</h5>
  Xtricorder is part of <a href="https://doi.org/10.1107/S2059798320014746">Phasertng</a> distributed within the
  Phenix and the CCP4 suite. Pressing the Xtricorder button it will analyse an mtz file in several ways
  and produces an output file with several additional columns. The output log file will subsequently be loaded in
  the HKLviewer as a tab next to the info and verbose text output.
  The most interesting new columns are the INFO, the ANISO and the TEPS columns. These columns
  are the information content of each reflection, the anisotropy correction terms and the TNCS correction
  terms, respectively. The TEPS data is not present if no patterson peak height larger than
  0.1 of the origin peak height is detected in the intensities.
  The INFO column will be absent if the original mtz file only contained amplitudes and not intensities.
  Once the mtz file produced by Xtricorder has been loaded the HKLviewer will display new buttons on the Quick View
  tab for visualising the TNCS modulation through the TEPS data which is very sensitive.
  <br />
  Above is a snapshot of the buttons available (blue bubble) if there is TNCS in the dataset analysed by Xtricorder.
  These are buttons are for visualising reflections with information content less than 0.35 bits, 
  for visualising anisotropy and TNCS correction terms. Reflections with information less
  than 0.35 bits roughly corresponds to I/SigI&lt;1 but reflections with low I/SigI values may occasionally have
  high information content.
  A tutorial on how to inspect TNCS modulation in a dataset is given in the
  <a href="../tuto_hklviewer/#inspecting_TNCS_modulation">tutorial section</a>.
  There is also a <a href="../tuto_hklviewer/#inspecting_information_content">tutorial</a>
  on how to reveal reflections with high information content but low I/SigI values.
  <br />
  Anisotropy can be shown by clicking the "Show anisotropy principal axes" or "Rotate around one anisotropy axis"
  button. This will display the anisotropy correction terms of the reflections, sort them into 8 bins and
  display only the reflections with very strong or very weak correction terms. The result is a hollow sphere of
  reflections encompassing a smaller sphere in the centre of reciprocal space. If the innermost sphere looks
  ellipsoidal then the dataset is very anisotropic. Below is an illustration of a rather anisotropic dataset.
  <br />
  <img style="max-width: 80%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_aniso.png' %}">
  <br /> The shape of the smaller sphere of reflections is ellipsoidal indicating strong diffraction along
  the direction of the principal axis labelled Anisotropy3.


  <a name="XDSGUI"></a>
  <h5 class="mt-4">XDSGUI</h5>
  The HKLviewer can be integrated with the
  <a href="https://strucbio.biologie.uni-konstanz.de/xdswiki/index.php/Main_Page">XDSGUI</a> to make it easy to visualise
  and inspect newly integrated datasets. This is a lightweight implementation that relies on the presence of a Phenix
  installation. Then the command-line to the HKLviewer needs to be specified in the XDSGUI and it will persists between
  sessions of running the XDSGUI. The command line that needs to be entered in the XDSGUI is the following:
<pre class="CodeGreen"><code>source &lt;path/to/phenix-installation&gt;/phenix_env.sh; cctbx.HKLviewer XDS_ASCII.HKL</code></pre>
  In the XDSGUI this should be entered under the button labelled "User defined command 3" found on the "Further analyses"
  part of the "tools" tab as illustrated on the screenshot of the
  <a href="{% static 'cctbx/img/hklviewer/XDSGUIscreenshot.jpg' %}">XDSGUI with the HKLviewer here</a>.
  Users of XDS may be interested in merging intensities on the fly as
  <a href="#merged_Intensities">described above</a> or examining multiplicities as in the
  <a href="../tuto_hklviewer/#inspecting_unmerged_dataset">tutorial here</a>.


  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Customising appearance of a particular type of dataset</h3>
  HKLviewer comes with default schemes for displaying different data types in of colours and sizes of
  the displayed reflections. These can be customised by the user and the settings will be persisted
  for next time the HKLviewer is started.

  <h5 class="mt-4">How to change colour mapping</h5>

  <p>
    The reflections are coloured according to
    <a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">colour gradient maps</a> of
    the Python module <a href="https://matplotlib.org/examples/color/colormaps_reference.html">matplotlib</a>.
    The colour mapping can be changed with a mouse-click on the upper left colour chart in the viewer area of a
    displayed dataset. This brings up the Colour gradient maps dialog shown below:
  </p>

  <img style="max-width: 70%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_001.png' %}">

  <p class="mt-3">
    A colour gradient map is an array of rgb values that usually varies smoothly between adjacent
    array elements. The mapping between a data value, x, and a colour gradient map is done with a power law:
  </p>

  \begin{equation}
  f(x) = ((x-x_{min})/(x_{max} - x_{min}))^p
  \end{equation}

  where \(x_{min} \) and \(x_{max}\) are the minimum and maximum data values found in the data set. The function
  \(f(x)\) as defined will take on values between 0 and 1. It is then mapped onto the array values of the colour
  gradient map chosen by the user. With \(x\) varying linearly between \(x_{min} \) and \(x_{max}\) and for \(p < 1\)
  the first part of the colour gradient array will be emphasized. If \(p > 1\) it will be the last part of the
  colour gradient array. Some data types such as intensities are better viewed with a value of \(p\) that 
  is smaller than 1. Other data types, like figure of merits are best viewed with a linear mapping between
   colours and the data values, i.e.  \(p\) should be set to 1. Below
  is an illustration of how different power factors affects the resultant colour mapping when the matplotlib colour
  scheme brg has been chosen as a gradient map.</p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/cuberootmappinggraph.png' %}">

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">How to change size of displayed reflections</h5>
  This is done from the Details tab by selecting the Sizing tab beneath the table of datasets.
  <br />

  <p>
    The size of each reflection is a function of its associated data value. Similar to colour mapping
    of data values a function is employed that produces a radius, \(r\), dependent on the data value, \(x\), and
    a power scale factor, \(p\).
  </p>

  \begin{equation}
  r(x) = ((x-x_{min})/(x_{max} - x_{min}))^p
  \end{equation}

  where \(x_{min} \) and \(x_{max}\) are the minimum and maximum data values found in the data set. The power
  scale factor can either be selected by the user or be determined atuomatically.</p>

  <img style="max-width: 90%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_006.png' %}">

  <p class="mt-3">
    For amplitudes or intensities where often there are orders of magnitude difference between
    the smallest and the largest data values it can be helpful to adjust the power scale factor to make all
    reflections the same size, \(p=0\), to ensure all recorded reflections are visible. Alternatively,
    to get a better view of the strength of the data an automatic power scale factor can be selected which
    will render the weakest reflections ten times smaller than the strongest reflections. When displaying sigmas of
    intensities or amplitudes this is reversed so that selecting automatic power scale factor will render the
    reflections with the smallest sigma ten times the size of the reflection with the largest sigma.
  </p>

  <!----------------------------------------------------------------------------->


  <h5 class="mt-5">Displaying map coefficients or phases</h5>

  <p>
    For data with map coeffficients or phases only the phase value (modulo 360) is used for the colour mapping.
    In this case it makes sense to choose a circular colour mapping, i.e. one where the colour at one end of the array
    equals the colour at the beginning of the array. Amongst the maps available from matplotlib these are hsv and
    gist_rainbow. For data with map coefficients or phases the
    <a href="#how-to-change-colour-mapping">power law mapping</a> is fixed at p=1.
  </p>

  <p>
    Clicking on a desired colour gradient in the Colour gradient maps dialog will instruct the HKLviewer to use
    this colour mapping for the displayed data or sigma values. This choice is used for all datasets of the same type as
    the currently shown one. This means that the colour mapping chosen for, say a dataset of amplitudes will cause any
    other dataset of amplitudes to use the same colour mapping.
  </p>

  <!----------------------------------------------------------------------------->

  <a name="expand_reflections"></a>
  <h3 class="mt-4">Expansion, Slicing and Binning of reflections</h3>
  These operations are all done from the Details tab by selecting the appropriate tab beneath the table of datasets.

  <h5 class="mt-4">How to expand reflections</h5>
  <p>
    Merged reflection data is usually stored with only the reflections that are unique under symmetry
    operations, meaning that no more than one data value is associated with an HKL index after symmetry
    operations associated with the space group
    have been applied. This subset of the recorded reflections are for convenience stored in the same wedge of the sphere
    of all reflections. For the P1 space group the wedge will be shaped as a half-sphere given that reflections present in
    such a wedge are the minimum number of reflections necessary for a complete (up to a given resolution) P1 data set,
    disregarding Friedel mates. For a high symmetry spacegroup such as a cubic spacegroup the wedge of reflections will
    be much smaller somewhat resembling a parsnip with sharp edges. An example of the difference between merged and
    unmerged data is given as a <a href="../tuto_hklviewer/#inspecting_unmerged_dataset">tutorial here</a>.
    <br>
    There are situations where it is preferable to inspect reflection data as if it had been stored as P1 data
    including Friedel mates. This is done by ticking the "Expand reflections" checkbox on the "Expansion"
    tab. This will apply the spacegroup rotations to all reflections and display them. If the reflection data file
    does contain reflections that are not unique under symmetry only the option of P1 expansion will be available.
  </p>

  <p>
    It is also possible to display "Missing reflections". These are the reflections that should have been present up to
    the resolution limit of the data set (i.e. the reflection recorded with the highest resolution) but are absent, say due
    to radiation damage of the crystal.<br>
    Below is an example of showing only the missing reflections for the data set 2B18 expanded to P1 including Friedel
    pairs:
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_003.png' %}">

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">How to slice reflections</h5>
  The easiest way to slice reflections is to press the "Show plane of Intensities" or "Show plane of amplitudes"
  button on the "Quick View" tab and then desired direction in which to slice the reflection on the adjacent
  drop down button. This will only slice reflections of datasets with amplitudes or intesities if present
  in the file.

  <h5 class="mt-5">How to slice reflections with arbitrarily oriented clip planes</h5>

  If a slice of reflections for a dataset other than amplitudes or intensities
  <a href="#how-to-display-slices-of-intensities-or-amplitudes">perpendicular to H,K or L axes</a>
  should be displayed this can be achieved from the Slicing tab that is
  found on the Details tab beneath the tabel of datasets. Double click the desired dataset in that table.
  Then expand the reflections to the full sphere on the <a href="#how-to-expand-reflections">Expansion tab</a>.
  Next, tick the checkbox, "Slice with a clip plane parallel to the screen". Three options invoked by
  the radio buttons are now present which are:
  <ol>
    <li>
      "use curent orientation", meaning orientation is done by dragging with the mouse,
    </li>
    <li>
      "is normal to", meaning a defined orientation of the sphere of reflections so that a
      selected vector from the drop down list of vectors is aligned
      perpendicular to the clip planes
    </li>
    <li>
      "is normal to the real space vector associated with", meaning a
      defined orientation of the sphere of reflections so that the real space vector associated with the selected vector from the
      drop down list of vectors is aligned perpendicular to the clip planes.
    </li>
  </ol>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_004.png' %}">
  Option 2 and 3 disables rotating with the mouse and only allows zooming and translating with the mouse.
  Option 3 only applies to selected vectors which are defined in terms of reciprocal coordinates (hkl) on the
  Vectors tab. It does not apply if the selected vector from the drop-down list is defined as a real space
  vector (such as a TNCS vector) or a rotation axis defined by a rotation operator.
  Option 3 will also display an equation that is satisfied for reflections points lying in this plane, give or take
  a bit of width of the displayed reflections as well as the width of the clip planes.

  By using <a href="#how-to-add-user-defined-vectors">user defined vectors</a> it is then possible to orient
  the sphere of reflections in a in a well defined manner and slice it with a clip plane.
  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">How to sort reflections into bins</h5>

  <p>
    From the Binning tab that is found below the table of datasets on the Details tab a data set can be
    sorted into bins according to resolution. If more data sets are present in the reflection file it
    can also be sorted according to values in those other data sets. The number of bins desired can be set from the spin
    control to a maximum of 40. By default HKLviewer will attempt to divide  the currently displayed data into bins
    having about the same number of reflections in each bin. This can be overwritten by entering a preferred threshold
    for a particular bin row under the "lower bin value" column.
  </p>
  <p>

    <!----------------------------------------------------------------------------->
    <h5 class="mt-5">Bin dataset according to resolution</h5>

    In the figure below 6 bins of resolution have been created for the FP,SIGFP dataset using the default bin thresholds.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_007.png' %}">

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">Adjusting bin thresholds</h5>

  <p>
    If one were to change the bin threshold for 4th bin from 2.27 to 2.1Å this is done by entering the
    new value in its place.
  </p>

  <img style="max-width: 45%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_008.png' %}">

  <p class="mt-3">
    Entering return on the keyboard processes the new value and computes new number of reflections
    in the bin and adjacent ones.
  </p>

  <img style="max-width: 45%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_009.png' %}">

  <p class="mt-3">
    The reflections in this bin can be visualised by deselecting reflections in all other bins in
    the opacity column.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_010.png' %}">

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">Bin dataset according to values in another dataset</h5>

  <p class="mt-3">
    As mentioned above data can be binned against other data values by selecting the desired data, sigmas
    or phases for binning from the drop-down list.
  </p>

  <img style="max-width: 70%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_011.png' %}">

  <p class="mt-3">
    Below is the data set FP,SIGFP binned according to the sigmas found in the data set but only
    displayed for the data values with sigmas larger than 5.7. This is done by un-ticking all the checkboxes but the
    last one in the opacity column.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_012.png' %}">

  <p class="mt-3">
    Data can also be made semi transparent by entering a value between 0 and 1 on the opacity
    column. This may be useful when showing vectors shorter than the radius of highest resolution shell of reflections.
    Beware that implementations of WebGL underpinning the HKLviewer may cause shading artifacts of
    objects when displayed semitransparently. If opacity is set below 0.3 reflections will not respond to hovering
    or clicking with the mouse.
  </p>

  <!----------------------------------------------------------------------------->
  <a name="vectors_tab"></a>
  <h3 class="mt-5">How to display spacegroup rotation operators and other vectors</h3>

  <!----------------------------------------------------------------------------->

  <p>
    On the Vectors tab that is found below the table of datasets on the Details tab
    various vectors can be displayed in reciprocal space. These are the rotation axes given by
    the space group as well as vectors defined by the user either in reciprocal or in real space fractional coordinates.
    Mtz files that have been analysed by Xtriage may provide a TNCS vector as well as rotation axes of proposed
    twinning operators.
    Mtz files that have been processed by Xtricorder may also provide a TNCS vector as well as
    principal axes of the anisotropy tensor. In the HKLviewer reciprocal space or real space vectors are
    defined with (0,0,0) as their origin so only their end coordinates are listed in the table. Whereas vectors
    defined as real space or reciprocal space vectors are displayed with their exact length
    axes of rotation operators are displayed with an arbitrary length ensuring that they are visible beyond the highest
    resolution shell of reflections.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_013.png' %}">

  <p class="mt-3">
    Above is an example of the viewer showing the reflections of a dataset together with one of the 2-fold rotation axes
    as defined by the spacegroup P 31 2 1.
    If only one vector is drawn the reflections can be oriented with respect to the vector being either parallel
    or perpendicular to the screen. It is then possible to also rotate the reflections around that vector which can be
    helpful for examining features in the dataset such as TNCS modulation.
  </p>

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">How to add user defined vectors</h5>

  <p>
    In addition to rotation axes given by the space group it is possible to explicitly enter a rotation operator and
    show its rotation axes. This is done by overwriting the "new name" field in the "draw" column of the table of rotation
    operators or vectors with a name of choosing, say "some_rot".
  </p>

  <img style="max-width: 70%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_014.png' %}">

  <p class="mt-3">
    For the dataset 2QCW with the spacegroup P31 2 1 the reflections are displayed below. Although not
    part of the spacegroup we can see that it is possible to apply a 6-fold rotation along the l-axis and have the
    reflections unambiguously transformed into new ones with the operation "-k,h+k,l". We enter that into the rotation
    column.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_015.png' %}">

  <p class="mt-3">
    HKLviewer will parse the operator when the enter key is pressed. If parsing succeeds the row in
    the table will become read-only and the name specified in the draw column will have "n-fold_" prefixed to it, where n
    is the number of times to apply this operation to achieve the identity operator.
  </p>

  <img style="max-width: 40%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_016.png' %}">

  <p class="mt-3">
    Rotation operators should be commensurate with the spacegroup. However, some leeway is allowed
    although grossly mismatching rotation operators will be refused with an error message.
    When displaying only one rotation vector the symmetry related reflections for a given reflection will be
    highlighted with vectors and tooltips when right-clicking on a particular reflection. For the six fold rotation
    operator we defined above this is shown below where a
    slice has been made at l=0 and reflections have been expanded to P1 and Friedel mates. This is useful when
    inspecting twin related reflections as discussed in the
    <a href="../tuto_hklviewer/#inspecting_a_twin_law">tutorial section</a>.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_017.png' %}">

  <p class="mt-3">
    It is also possible to enter a reciprocal space vector. To do this first overwrite the "new name"
    field in the "draw" column with a chosen name, say "myHKL". Then enter the reciprrocal space vector in the same row
    under the "as hkl" column.
  </p>

  <img style="max-width: 55%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_018.png' %}">

  <p class="mt-3">
    When the HKLviewer parses the coordinates the row will become read-only and the coordinates
    encapsulated by brackets.
  </p>

  <img style="max-width: 55%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_019.png' %}">

  <p class="mt-3">
    Real space fractional vectors may also be entered in the same manner as for reciprocal space vectors.
    Enter those in the "as abc" column.
  </p>

  <img style="max-width: 55%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_020.png' %}">

  <p class="mt-3">
    The unit cells for real space and reciprocal space can also be drawn to help the user more easily perceive
    the location of vectors or axes in the real space and the reciprocal space unit cells.
    Below is the 2QCW data set displayed with its realspace unit cell,
    the 6-fold rotation axis, the myHKL and the myABC vectors defined above.
  </p>

  <img style="max-width: 80%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_021.png' %}">

  <!----------------------------------------------------------------------------->

  <h3 class="mt-5">How to make a new dataset</h3>
  <p>
    A new dataset can be created from one or two existing dataset that are present in the file loaded into
    the HKLviewer. The way to create a new dataset is from python scripting. The datasets present in the HKLviewer are
    stored as cctbx.miller.array python data types. The cctbx.miller.array module provides a rich API of  functions for
    crystallography which makes many crystallographic computational tasks simple to do from python scripting.
  </p>

  <p>
    To get started, right-click a dataset in the upperleft table in the HKLviewer which you want to use for
    creating a new dataset. This invokes a context menu. Then select the "Make a new dataset from this dataset and another
    dataset" menu item. This invokes the "Create a new reflection dataset" dialog.
  </p>

  <img style="max-width: 80%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_022.png' %}">

  <p class="mt-3">
    In the textbox a python expression that defines the new dataset, newarray, can be entered.
    Below that, a label for the dataset should also be entered. Pressing the "Compute new reflection dataset" button then
    parses and executes the python expression. If succesful the new dataset with the specified column label will appear
    at the bottom of the table of existing datasets and automatically be displayed in the viewer. For convenience
    newarray is initialised to a copy of array1 meaning that all variables of this class such as
    _data, _sigmas, _indices arrays and _info class are copies of the same variables in array1. The objective of creating a
    new reflection dataset often only amounts to changing the values of _data and perhaps the _sigmas arrays.
  </p>

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">Variables</h5>

  <p>
    The following variables are available for a python expression submitted in
    the "Create a new reflection dataset" dialog:
  </p>

  <table class="table">
    <thead>
      <tr>
        <th scope="col">Variable or member function</th>
        <th scope="col">Type</th>
        <th scope="col">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>newarray</td>
        <td>cctbx.miller.array</td>
        <td>The new dataset that is computed from the python script</td>
      </tr>
      <tr>
        <td>array1 or array2</td>
        <td>cctbx.miller.array</td>
        <td>
          array1 is the variable name of dataset that was right-clicked in the upperleft table of
          dataset.<br>
          array2 is the variable name of the dataset that optionally can be selected from the dropdown list
        </td>
      </tr>
      <tr>
        <td>newarray._data, array1.data() or array2.data()</td>
        <td>flex.double, flex,complex, flex.int or flex.hendrickson_lattman</td>
        <td>
          Observed data values, figure of merits, map coefficients, Rfree or other column values present
          in the reflection file.
        </td>
      </tr>
      <tr>
        <td>newarray._sigmas, array1.sigmas() or array2.sigmas()</td>
        <td>flex.double or None if not provided</td>
        <td>Observed sigma values associated with the data values.</td>
      </tr>
      <tr>
        <td>array1.indices() or array2.indices()</td>
        <td>flex.miller_index </td>
        <td>
          HKL indices of each reflection. If array2 has been selected for the computation as well, the
          indices will be the common subset of indices of both datasets.
        </td>
      </tr>
      <tr>
        <td>dres</td>
        <td>flex.double</td>
        <td>Resolution of each HKL index</td>
      </tr>
    </tbody>
  </table>

  <p>The dres variable is provided as a shorthand for <code>array1.unit_cell().d(array1.indices())</code>.</p>

  <!----------------------------------------------------------------------------->

  <h5 class="mt-5">Examples of creating a new dataset</h5>

  <p>
    When creating a new dataset copies, the objective is to define <code>newarray</code> as a
    new <code>cctbx.miller.array</code> object or to assign its attributes <code>newarray._data</code> and
    <code>newarray._sigmas</code> to flex arrays computed in the script. The <code>newarray</code> is initalised to
    the dataset that was right-clicked for invoking the "Create a new reflection dataset" dialog. So
    the <code>newarray.indices</code> attribute needs not specifying. The <code>array1</code> and <code>array2</code>,
    of the selected datasets are available for scripting in the "Create a new reflection dataset" dialog. The data(),
    sigmas() and indices() member functions of <code>array1</code> and <code>array2</code> can then be used for
    composing the new dataset. A few examples are given in the table below:
  </p>

  <table class="table">
    <thead>
      <tr>
        <th scope="col">Objective</th>
        <th scope="col">Python script to be entered</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Calculate normalized structure factors, E, from amplitude, F, or intensity, I, dataset.</td>
        <td>newarray = array1.normalize()</td>
      </tr>
      <tr>
        <td>Calculate I/SigI for an intensity dataset.</td>
        <td>
          dat = array1.data() / array1.sigmas()<br>
          newarray._data = dat<br>
          newarray._sigmas = None<br>
          newarray.set_observation_type(None)
        </td>
      </tr>
      <tr>
        <td>Multiply data values in one dataset with the squareroot of data values in another dataset</td>
        <td>
          dat = array1.data() * flex.sqrt( array2.data())<br>
          newarray._data = dat<br>
          newarray._sigmas = None<br>
          newarray.set_observation_type(None)
        </td>
      </tr>
      <tr>
        <td>French-Wilson massage intensity data values.</td>
        <td>newarray = array1.french_wilson()</td>
      </tr>
    </tbody>
  </table>

  <p>
    The important thing to bear in mind is that the newarray._data and optionally newarray._sigmas should
    be of type flex arrays and not scalar values, list or tuples. Many mathematical functions have been overloaded.
    So when computing the squareroot, the absolute value or raising all elements of a flex double array to a
    certain power use flex.sqrt(array1.data()) etc. Likewise, operations concerning two miller_array objects usually
    operates on their data values looped over all matching hkl indices.
    Avoid using a for-loop or list comprehension over all elements in a
    flex array in the python script.
  </p>
  <!----------------------------------------------------------------------------->

  <h5 class="mt-4">Further API details</h5>

  <p>
    There are many more functions available from the
    <a href="https://cctbx.github.io/cctbx/cctbx.miller.html#the-miller-array">cctbx.miller.array</a> class.
    Details about flex arrays can be found <a href="https://cctbx.github.io/scitbx/scitbx.array_family.html">here</a>
    and <a href="http://cci.lbl.gov/docs/cctbx/doc_low_flex_array/">here</a>.
  </p>


  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Saving datasets</h3>

  <p>
    Once new datasets have been created it is possible to save these from the File menu by clicking the
    "Save Reflection File" item. Supported file formats are MTZ and CIF. If a reflection file contains unmerged data
    with multiple values for one or more indices each dataset will be saved in separate CIF files. Currently it is not
    possible to save unmerged data in the MTZ format.
  </p>

  <!----------------------------------------------------------------------------->

  <a name="show_table_of_datasets"></a>
  <h3 class="mt-4">How to show a table of one or more dataset values</h3>

  <p>
    With a right click on the upper-left table of datasets in the data file one or more datasets can
    be tabulated from the context menu. First highlight the datasets of interest, then right click these,
    then click on <code>Show a table of &lt;some datasets&gt;...</code>.
    This brings up a window with tabulated data as it is stored in the reflection data file as well as
    the ones that may have been created from one of the predefined buttons or
    <a href="#how-to-make-a-new-dataset">as decribed above</a>.
  </p>

  <img style="max-width: 100%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_023.png' %}">

  <p class="mt-3">
    The table can be sorted according to the values of other dataset in the file or to the resolution.
    Double clicking a row in the table will cause the viewer to zoom in on that particular reflection and highlight it
    with a red mesh.
  </p>

  <img style="max-width: 85%;" src="{% static 'cctbx/img/hklviewer/doc_hklviewer_024.png' %}">

  <p class="mt-3">
    Conversely will a right-click on a displayed reflection in the viewer retrieve and highlight that
    reflections data value in the table.<br>
    The tabulated datasets will remain unchanged when the displayed reflections are transformed by expanding to
    Friedel mates, P1 or lower symmetry spacegroups. This also means that double clicking a symmetry copy generated from
    expanding the dataset to P1 or Friedel mates will only retrieve the original HKL index and its data value in the table.
  </p>


  <!----------------------------------------------------------------------------->

  <h3 class="mt-4">Commandline Options</h3>
  Commandline options available when invoking HKLviewer are:
  <ul>
    <li>
      <code>hklin=reflection_filename</code> or just <code>reflection_filename</code> tells HKLviewer to
      load the reflection file with the name specified.
    </li>
    <li>
      <code>remove_settings</code> for deleting all persisted user settings such as colour and reflection size
      schemes from your PC. Next time HKLviewer is started factory default settings will be used.
    </li>
    <li>
      <code>show_master_phil</code> for printing the list of default PHIL parameters
      as <a href="#default_PHIL"> described below</a>
    </li>
    <li>
      <code>devmode</code> for invoking the Chromium browser debugger in a separate window.
    </li>
    <li>
      <code>UseOSBrowser=&lt;browser_name&gt;</code> for using a particular browser when running
      HKLviewer from python script.
    </li>
    <li>
      <code>closing_time=&lt;seconds&gt;</code> instructs HKLviewer to run for at most 2*seconds.
      This is useful during regression tests.
    </li>
    <li>
      <code>output_filename=&lt;filename&gt;</code> instructs HKLviewer to write all printed output to the specified file.
    </li>
    <li>
      <code>phil_file=&lt;filename&gt;</code> instructs HKLviewer to display a dataset in a manner
      specified by the user defined PHIL strings in the file named filename.
    </li>
    <li>
      <code>image_file=&lt;imagename&gt;</code> instructs HKLviewer to save an image of what is displayed in the browser.
      This is only available if <code>phil_file=&lt;filename&gt;</code> has also been specified. Useful for debugging.
    </li>
    <li>
      <code>verbose=&lt;[1;4],some_strings&gt;</code>
      Instruct HKLviewer to print more or less verbose information with a combination of
      numbers and or strings. verbose=0 prints the least information whereas verbose=4 prints overly detailed
      information when using the HKLviewer. <code>&lt;some_string&gt;</code> may be a concatenation of
      one or more of the strings "threadingmsg", "frustum", "angles", "vector", "orientmsgm", "browser".
      This will print additional specific debugging information during use.
    </li>

  </ul>
  <!----------------------------------------------------------------------------->

  <a name="default_PHIL"></a>
  <h4 class="mt-4">Full list of default PHIL parameters</h4>
  The HKLviewer is controlled by <a href="../doc_low_phil/">PHIL</a>  parameter values. It is not necessary to know
  these when you are using the HKLviewer from the Qt GUI. The complete list of parameters are given here to serve as
  a reference when defining custom buttons for the Quick View tab as <a href="#user-defined-buttons"> described above</a>
  as well as for scripting the HKLviewer from a cctbx.python prompt.

<pre><code>
openfilename = None
  .help = "Name of file with one or more datasets"
  .type = path
use_provided_miller_arrays = False
  .help = "internal flag"
  .type = bool
savefilename = None
  .help = "Name of file where the user wants to save datasets. Optionally used"
          "after making new datasets from existing ones"
  .type = path
save_image_name = None
  .help = "Name of image file (PNG format) where the current displayed"
          "reflections will be saved to at the users request"
  .type = path
merge_data = False
  .help = "internal flag"
  .type = bool
miller_array_operation = ''
  .help = "Python syntax string defining a new cctbx.miller_array object from"
          "one or two exisitng miller arrays  in the loaded data file. The"
          "CCTBX API is used for this"
  .type = str
spacegroup_choice = None
  .type = int(allow_none=True)
using_space_subgroup = False
  .help = "internal flag"
  .type = bool
draw_real_space_unit_cell = False
  .help = "show real space unit cell"
  .type = bool
draw_reciprocal_unit_cell = False
  .help = "show reciprocal space unit cell"
  .type = bool
real_space_unit_cell_scale_fraction = 0.0
  .help = "Parameter specifying the scale at which to display the unit cell"
          "compared to reciprocal space. 0 means  true to scale of the size of"
          "the reciprocal lattice. 1 means close to the radius of the"
          "displayed sphere of reflections."
  .type = float(value_min=0, value_max=1, allow_none=True)
reciprocal_unit_cell_scale_fraction = 0.0
  .help = "Parameter specifying the scale at which to display the reciprocal"
          "unit cell compared to reciprocal space.  0 means true to scale of"
          "the size of the reciprocal lattice. 1 means close to the radius of"
          "the displayed sphere of reflections."
  .type = float(value_min=0, value_max=1, allow_none=True)
clip_plane
  .help = "Optionally imposed clip plane which is always parallel to the"
          "screen."
{
  hkldist = 0.0
    .help = "Distance from origin of the center of the clip plane.  If the"
            "clip plane is normal to a reciprocal lattice vector or the"
            "associated real space  vector the unit of hkldist is the length"
            "of the reciprocal lattice vector.  If the clip plane is normal to"
            "a real space vector the unit of hkldist is the  inverse of its"
            "real space length."
    .type = float(allow_none=True)
  normal_vector = ""
    .type = str
  is_assoc_real_space_vector = False
    .help = "Indicate if using associated real space vector to the selected"
            "reciprocal space vector"
    .type = bool
  normal_vector_length_scale = -1
    .help = "If value is negative the unit length of hkldist is used as the"
            "scale."
    .type = float(allow_none=True)
  clip_width = None
    .help = "If value is not None then we are clipping. If auto_clip_width is"
            "True this value is ignored."
    .type = float(allow_none=True)
  auto_clip_width = True
    .help = "If true compute appropriate clip plane width. Otherwise use"
            "clip_width value"
    .type = bool
  fractional_vector = reciprocal *realspace
    .type = choice
}
wrap_labels = 15
  .help = "Number of letters for wrapping long miller array labels. If less"
          "than 1 no wrapping is done"
  .short_caption = "Wrap width for labels"
  .type = int(allow_none=True)
delimiter = "|"
  .help = "column delimiter"
  .short_caption = "column delimiter when printing table to standard output"
  .type = str
selected_info
  .help = "If values are set to True then tabulate respective properties of"
          "datasets in the reflection file."
{
  labels = True
    .help = "Name of data array"
    .short_caption = Labels
    .type = bool
  description = True
    .help = "Type of data"
    .short_caption = Type
    .type = bool
  wavelength = True
    .help = "Recorded wavelength/Å"
    .short_caption = "λ/Å"
    .type = bool
  n_reflections = True
    .help = "Number of reflections"
    .short_caption = "#HKLs"
    .type = bool
  span = True
    .help = "Crude range of hkl indices"
    .short_caption = Span
    .type = bool
  minmax_data = True
    .help = "minimum, maximum values of data"
    .short_caption = "min,max data"
    .type = bool
  minmax_sigmas = True
    .help = "minimum, maximum values of sigmas"
    .short_caption = "min,max sigmas"
    .type = bool
  data_sigdata = False
    .help = "Average value of data/sigma"
    .short_caption = DatSigDat
    .type = bool
  data_sigdata_max = False
    .help = "maximum value of data/sigma"
    .short_caption = MaxDatSigDat
    .type = bool
  d_minmax = True
    .help = "d_min,d_max/Å"
    .short_caption = "d_min,d_max/Å"
    .type = bool
  unit_cell = False
    .help = "Unit cell parameters (a/Å, b/Å, c/Å, α°, β°, γ°)"
    .short_caption = "unit cell (a/Å, b/Å, c/Å, α°, β°, γ°)"
    .type = bool
  space_group = False
    .help = "Space group"
    .short_caption = "space group"
    .type = bool
  n_centrics = False
    .help = "Number of centric reflections"
    .short_caption = "#centrics"
    .type = bool
  is_anomalous = True
    .help = "Is data anomalous"
    .short_caption = Anomalous
    .type = bool
  is_symmetry_unique = True
    .help = "Is data symmetry unique"
    .short_caption = "Sym.uniq."
    .type = bool
  n_sys_abs = False
    .help = "Systematic absences"
    .short_caption = "#Syst.abs."
    .type = bool
  data_completeness = True
    .help = "Completeness in resolution range"
    .short_caption = "Data compl."
    .type = bool
  data_compl_infty = False
    .help = "Completeness with d_max=infinity"
    .short_caption = "Compl.inf."
    .type = bool
  ano_completeness = False
    .help = "Anomalous completeness in resolution range"
    .short_caption = Ano.complete
    .type = bool
  ano_mean_diff = False
    .help = "Mean anomalous difference."
    .short_caption = "Ano.dif. "
    .type = bool
  n_bijvoet = False
    .help = "Number of Bijvoet pairs"
    .short_caption = "#Bijvoets"
    .type = bool
  n_singletons = False
    .help = "Number of lone anomalous reflections"
    .short_caption = "#Singletons"
    .type = bool
}
binning {
  scene_bin_thresholds = []
    .type = floats
  binner_idx = 0
    .help = "Index in list of binners, say ['Resolution', 'Singletons',"
            "'I,SIGI', 'Sigmas of I,SIGI',..] "
    .type = int(allow_none=True)
  binlabel = None
    .help = "Element in list of binners, say ['Resolution', 'Singletons',"
            "'I,SIGI', 'Sigmas of I,SIGI',..] "
    .type = str
  bin_opacity = None
    .help = "A list of tuples (alpha, idx) with as many or more elements as"
            "the current number of binners. List is cast to a string"
    .type = floats(size=2)
    .multiple = True
  nbins = 1
    .type = int(value_min=1, value_max=40, allow_none=True)
}
viewer {
  data_array {
    label = None
      .help = "If provided this assigns scene_id with a value corresponding to"
              "the numbering  order the miller array with this label is found"
              "in the reflection data file."
      .type = str
    phasertng_tag = None
      .help = "If provided this assigns scene_id with a value corresponding to"
              "the numbering  order the miller array with a label found in the"
              "parsed history of the MTZ header."
      .type = str
    datatype = None
      .help = "In case label is not found this assigns scene_id with a value"
              "corresponding to  the first miller array of this data type"
              "found in the reflection data file."
      .type = str
  }
  scene_id = None
    .type = int(allow_none=True)
  ncolourlabels = 6
    .help = internal
    .type = int(allow_none=True)
  show_vector = ''
    .help = "Vectors to display. Each show_vector is a stringified python list"
            "consisting of the name  of the vector as the first element and a"
            "boolean value as the second element indicating  visibility of the"
            "vector, say show_vector =  ['4-fold#2', True]\"\""
    .type = str
    .multiple = True
  show_all_vectors = 0
    .type = int(value_min=-1, value_max=1, allow_none=True)
  user_vector
    .help = "Vectors the user add in addition to existing vectors (rotations,"
            "TNCS, anisotropy principal axes).  A vector has to be entered"
            "either as a rotation, a real space or a reciprocal space vector. "
            "The label is required but only one of hkl_op, abc or hkl must be"
            "specified"
    .multiple = True
  {
    label = ""
      .type = str
    hkl_op = ""
      .help = "Rotation operation specified with h,k and l"
      .type = str
    abc = ""
      .help = "Real space vector in real space fractional coordinates"
      .type = str
    hkl = ""
      .help = "Reciprocal space vector in reciprocal space fractional"
              "coordinates"
      .type = str
  }
  show_hkl = ""
    .help = "Highlight a reflection with a red meshed wire net surrounding it."
    .type = str
  is_parallel = False
    .help = "Specifies if reciprocal space is rotated to have a selected and"
            "displayed vector being parallel  or perpendicular to the screen."
    .type = bool
  fixorientation = vector *None
    .help = "fixes orientation of reciprocal space to be aligned with a vector"
            "so only mouse zoom will work"
    .type = choice
  angle_around_XHKL_vector = 0.0
    .type = float(allow_none=True)
  angle_around_YHKL_vector = 0.0
    .type = float(allow_none=True)
  angle_around_ZHKL_vector = 0.0
    .type = float(allow_none=True)
  angle_around_vector = "[0,0]"
    .help = "Rotation with a specified angle of all reflections around a"
            "specified vector,  say angle_around_vector =  ['2-fold#5',"
            "13.0]\"\""
    .type = str
  animate_rotation_around_vector = "[0,0]"
    .help = "Continuous rotation of all reflections around a specified vector"
            "at a certain speed,  say animate_rotation_around_vector = "
            "['2-fold#5', 10.0]\"\""
    .type = str
}
hkls {
  nth_power_scale_radii = 0.0
    .help = "A number for dampening or enhancing the difference between the"
            "smallest and the largest values.  A negative number means that a"
            "large data value is rendered with a smaller radius than  a small"
            "data value will be. For nth_power_scale_radii=0 all data values"
            "are rendered with  the same radius. For nth_power_scale_radii=1"
            "data values are rendered with radii proportional  to the data"
            "values. If nth_power_scale_radii=NaN an automatic value is"
            "computed that maps the  smallest values to 0.1 of the largest"
            "values."
    .type = float(allow_none=True)
  scale = 1
    .help = "Increase/decrease radii with this factor."
    .type = float(allow_none=True)
  sigma_color_radius = False
    .help = "If set to True then colour mapping is based on sigma values if"
            "dataset contains sigmas."
    .type = bool
  expand_to_p1 = False
    .help = "Expand data to P1."
    .type = bool
  expand_anomalous = False
    .help = "Expand data to Friedel pairs."
    .type = bool
  show_missing = False
    .help = "Show those reflections within the highest resolution sphere that"
            "are missing from the dataset."
    .type = bool
  show_only_missing = False
    .type = bool
  show_systematic_absences = False
    .type = bool
  slice_mode = False
    .help = "Deprecated: Show only a slice of reflections. Superseeded by"
            "applying clip planes."
    .type = bool
  slice_axis = *h k l
    .help = "Deprecated: Show only a slice of reflections. Superseeded by"
            "applying clip planes."
    .type = choice
  slice_index = 0
    .help = "Deprecated: Show only a slice of reflections. Superseeded by"
            "applying clip planes."
    .type = int(allow_none=True)
  color_scheme = magma inferno plasma viridis cividis twilight \
                 twilight_shifted turbo Blues BrBG BuGn BuPu CMRmap GnBu \
                 Greens Greys OrRd Oranges PRGn PiYG PuBu PuBuGn PuOr PuRd \
                 Purples RdBu RdGy RdPu RdYlBu RdYlGn Reds Spectral Wistia \
                 YlGn YlGnBu YlOrBr YlOrRd afmhot autumn binary bone *brg bwr \
                 cool coolwarm copper cubehelix flag gist_earth gist_gray \
                 gist_heat gist_ncar gist_rainbow gist_stern gist_yarg \
                 gnuplot gnuplot2 gray hot hsv jet nipy_spectral ocean pink \
                 prism rainbow seismic spring summer terrain winter Accent \
                 Dark2 Paired Pastel1 Pastel2 Set1 Set2 Set3 tab10 tab20 \
                 tab20b tab20c magma_r inferno_r plasma_r viridis_r cividis_r \
                 twilight_r twilight_shifted_r turbo_r Blues_r BrBG_r BuGn_r \
                 BuPu_r CMRmap_r GnBu_r Greens_r Greys_r OrRd_r Oranges_r \
                 PRGn_r PiYG_r PuBu_r PuBuGn_r PuOr_r PuRd_r Purples_r RdBu_r \
                 RdGy_r RdPu_r RdYlBu_r RdYlGn_r Reds_r Spectral_r Wistia_r \
                 YlGn_r YlGnBu_r YlOrBr_r YlOrRd_r afmhot_r autumn_r binary_r \
                 bone_r brg_r bwr_r cool_r coolwarm_r copper_r cubehelix_r \
                 flag_r gist_earth_r gist_gray_r gist_heat_r gist_ncar_r \
                 gist_rainbow_r gist_stern_r gist_yarg_r gnuplot_r gnuplot2_r \
                 gray_r hot_r hsv_r jet_r nipy_spectral_r ocean_r pink_r \
                 prism_r rainbow_r seismic_r spring_r summer_r terrain_r \
                 winter_r Accent_r Dark2_r Paired_r Pastel1_r Pastel2_r \
                 Set1_r Set2_r Set3_r tab10_r tab20_r tab20b_r tab20c_r
    .help = "The selected colour scheme for colouring reflections. These are"
            "all defined by MatPlotLib."
    .type = choice
  color_powscale = 1.0
    .help = "color_powscale skews the colour mapping towards the smaller data"
            "values for color_powscale > 1 but skews it towards the larger"
            "data values for 0 < powscale < 1. Typically for intensity data a"
            "value around 0.25 is appropriate for emphasizing differences"
            "between stronger and weaker data. For amplitude data a value of"
            "around 0.5 is better. When displaying map coefficients where"
            "complex values are converted into amplitudes and phases"
            "color_powscale  remains equal to 1."
    .type = float(allow_none=True)
  show_anomalous_pairs = False
    .help = "Internal use only. Applies when merging data."
    .type = bool
}
NGL {
  mouse_sensitivity = 0.06
    .help = "Controls the speed of movement when adjusting view with the mouse"
    .type = float(allow_none=True)
  tooltip_alpha = 0.80
    .help = "Opacity of tooltips showing data values of reflections when"
            "clicking or hovering the mouse on reflections"
    .type = float(allow_none=True)
  fontsize = 9
    .help = "Font size for window displaying reflections"
    .type = int(allow_none=True)
  background_colour = 'rgb(127, 127, 127)'
    .help = "String of RGB colour values for the background of the browser"
    .type = str
  show_tooltips = none *click hover
    .help = "Specifies whether tooltips for reflections should show by"
            "hovering or by clicking on a reflection If the displayed data has"
            "a very large number of reflections it is best to select "
            "click\"\""
    .type = choice
  camera_type = *orthographic perspective
    .type = choice
}
action = *is_running is_terminating reset_view
  .type = choice
tabulate_miller_array_ids = "[]"
  .type = str
tooltip_data = "[]"
  .type = str
use_wireframe = False
  .help = "Draw objects using wireframe mesh"
  .type = bool
</code></pre>



  <h3 class="mt-4">Bug reports or queries</h3>

  <p>
    Please submit bug reports or questions to rdo20@cam.ac.uk or cctbx@cci.lbl.gov. For suggested
    enhancements to the HKLviewer feel free either to email it or to make a pull request on
    <a href="https://github.com/cctbx/cctbx_project">https://github.com/cctbx/cctbx_project</a>.
  </p>


  <br>
  <br>


  <!----------------------- EDIT END ---------------------------->
  <!-- DO NOT EDIT ANYTHING BELOW!!!! -->
</div> <!-- end col-sm-9 -->

<!-- automatic table of contents
     located in the sidebar; will move to the top on a small screen -->
<div class="col-sm-3 mt-5">
  <nav id="toc" data-toggle="toc"></nav>
</div> <!-- end col-sm-3 -->


{% endblock %}
