{% extends "cctbx/header.html" %}

{% load static %}

{% block content %}

<div class="col-sm-9 main">
<!-- DO NOT EDIT ANYTHING ABOVE!!!! -->
<!----------------------- EDIT START ---------------------------->

<h2><center>libtbx.phil - Python-based hierarchical interchange language</center></h2>

<p class="lead mt-4">Learn how to use <code>Phil</code>, the module for managing parameters and inputs.<br>
Author: Ralf W. Grosse-Kunstleve</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Links</h3>

<p>The source code examples below are available as one file
<a href="https://github.com/cctbx/cctbx_project/blob/master/iotbx/examples/libtbx_phil_examples.py">here</a><br>
<br>
<code>libtbx.phil</code> is part of the cctbx open source libraries:<br>
<a href="https://github.com/cctbx/cctbx_project">https://github.com/cctbx/cctbx_project</a></p>

<!----------------------------------------------------------------------------->

<h3 class="mt-3">Phil overview</h3>

<p>Phil (Python-based hierarchical interchange language) is a module
for the management of parameters and inputs. Many applications use command-line options as a user interface (e.g. based on Python's optparse, a.k.a Optik). This approach works well for small applications, but has it limitations for more complex applications with a large set of parameters.</p>

<p>A simple Phil file as presented to the user may look like this:</p>


<pre class="bg-code-DL"><code>minimization.input {
  file_name = experiment.dat
  label = set2
}
minimization.output {
  model_file = final.mdl
  plot_file = None
}
minimization.parameters {
  method = *bfgs conjugate_gradient
  max_iterations = 10
}
</code></pre>

<p>Phil is designed with a minimal syntax. An important goal is to
enable users to get started just by looking at defaults and examples,
without having to read documentation.</p>

<p>The Phil syntax has only two main elements, <code>phil.definition</code> (e.g. <code>max_iterations = 10</code>) and <code>phil.scope</code> (e.g. <code>minimization.input { }</code>).
To make this syntax as user-friendly as possible, strings
do not have to be quoted and, unlike Python, indentation is not
syntactically significant. E.g. this:</p>

<pre class="bg-code-DL"><code>minimization.input {
file_name="experiment.dat"
labels="set2"
}
</code></pre>

<p>is equivalent to the corresponding definitions above.</p>

<p>Scopes can be nested recursively. The number of nesting levels is
limited only by Python's recursion limit (default 1000). To maximize
convenience, nested scopes can be defined in two equivalent ways.
For example:</p>

<pre class="bg-code-DL"><code>minimization {
  input {
  }
}
</code></pre>

<p>is equivalent to:</p>

<pre class="bg-code-DL"><code>minimization.input {
}
</code></pre>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Features of Phil</h3>

<p>Phil is much more than just a parser for a very simple, user-friendly
syntax. Major Phil features are:</p>

<ul>
  <li>
    The concepts of <code>master files</code> and <code>user files</code>. The syntax
    for the two types of Phil files is identical, but the processed
    Phil files are used in different ways. I.e. the concepts exist
    only at the semantical level. The "look and feel" of the files is
    uniform.
  </li>
  <li>
    Interpretation of command-line arguments as Phil definitions.
  </li>
  <li>
    Merging of (multiple) Phil files and (multiple) Phil definitions
    derived from command-line arguments.
  </li>
  <li>
    Automatic conversion of Phil files to Python objects
    which are essentially independent of the Phil system. I.e.
    core algorithms using Phil-derived parameter objects do not
    actually have to depend on Phil.
  </li>
  <li>
    The reverse conversion of (potentially modified) Python
    objects back to Phil files. This could also be viewed as a Phil
    pretty printer.
  </li>
  <li>
    Shell-like variable substitution using $var and ${var} syntax.
  </li>
  <li>
    <code>include</code> syntax to merge Phil files at the parser level,
    or to import Phil objects from other Python scripts.
  </li>
</ul>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Master files</h3>

<p>Master files are written by the software developer and include
"attributes" for each parameter, such as the type (integer,
floating-point, string, etc.) and support information for graphical
interfaces. For example:</p>

<pre class="bg-code-DL"><code>minimization.parameters
  .help = "Selection and tuning of minimization algorithm."
  .expert_level = 0
{
  method = *bfgs conjugate_gradient
    .type = choice
  max_iterations = 10
    .type = int
    .input_size = 8
}
</code></pre>

<p>The is the last part of the output of this command:</p>

<pre class="bg-code-DL"><code>libtbx.phil --show-some-attributes example.params
</code></pre>

<p>Run this command with <code>--show-all-attributes</code> to see the full set
of <code>definition</code> and <code>scope</code> attributes. This output tends to get very long, but end-users don't have to be aware of this, and even
programmers only have to deal with the attributes they want to change.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">User files</h3>

<p>User files are typically generated by the application. For example:</p>

<pre class="bg-code-DL"><code>minimization.quick --show_defaults
</pre></code>

<p>will process its master file and show only the most
relevant parameters, classified by the software developer as
<code>.expert_level = 0</code> (default). E.g. the <code>minimization.parameters</code> scope in the example above is not shown. The attributes are also
not shown. Therefore the output is much shorter compared to the
<code>libtbx.phil --show-some-attributes</code> output above:</p>

<pre class="bg-code-DL"><code>minimization.parameters {
  method = *bfgs conjugate_gradient
  max_iterations = 10
}
</pre></code>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Command-line arguments</h3>

<p>In theory, the user could save and edit the generated parameter files.
However, in many practical situations this manual step can be
avoided. Phil is designed with the idea that the application inspects
all input files and uses the information found to fill in the blanks
automatically. This is not only convenient, but also eliminates
the possiblity of typing errors. In addition, the user can specify
parameters directly on the command line, and this information is also
use to fill in the blanks.</p>

<p>Command-line arguments that are not file names or options prefixed
with '--' (like '--show_defaults' above) should be given to Phil
for examination. E.g., this is a possible command:</p>

<pre class="bg-code-DL"><code>minimization.quick experiment.dat output.plot_file=plot.pdf
</code></pre>

<p>First the application should check if an argument is the name of a
file that can be opened. Assume this succeeds for the first argument,
so the processing of this argument is finished. Assume further that a
file with the name 'output.plot_file=plot.pdf' does not exist. This
argument will therefore be interpreted with Phil. The next section
presents an example.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">fetch: merging of Phil objects</h3>

<p>The Phil parser converts master files, user files and command line
arguments to uniform Phil objects which can be merged to generate a
combined set of "working" parameters used in running the application.
We demonstrate this by way of a simple, self-contained Python script
with embedded Phil syntax:</p>

<pre class="bg-code-DL"><code>from libtbx.phil import parse

master_phil = parse("""
  minimization.input {
    file_name = None
      .type = path
    label = None
      .type = str
  }
  """)

user_phil = parse("""
  minimization.input {
    file_name = experiment.dat
  }
  """)

command_line_phil = parse(
  "minimization.input.label=set2")

working_phil = master_phil.fetch(
  sources=[user_phil, command_line_phil])
working_phil.show()
</code></pre>

<p><code>master_phil</code> defines all available parameters including the
type information. <code>user_phil</code> overrides the default 'file_name'
assignment but leaves the 'labels' undefined. These are defined
by a (fake) command-line argument. All inputs are merged via
<code>master_phil.fetch()</code>.<br>
<code>working_phil.show()</code> produces:</p>

<pre class="bg-code-DL"><code>minimization.input {
  file_name = experiment.dat
  label = set2
}</code></pre>

<p>Having to type in fully qualified parameter names (e.g.
<code>minimization.input.labels</code>) can be very inconvenient. Therefore
Phil includes support for matching parameter names of command-line
arguments as substrings to the parameter names in the master files:</p>

<pre class="bg-code-DL"><code>argument_interpreter = master_phil.command_line_argument_interpreter(
  home_scope="minimization")

command_line_phil = argument_interpreter.process(
  arg="minimization.input.label=set2")
</code></pre>

<p>This works even if the user writes just 'label=set2' or even
'put.lab=x1 x2'. The only requirement is that the substring leads
to a unique match in the master file. Otherwise Phil produces a helpful
error message. For example:</p>

<pre class="bg-code-DL"><code>argument_interpreter.process("a=set2")
</code></pre>

<p>leads to:</p>

<pre class="CodeGreen"><code>Sorry: Ambiguous parameter definition: a = set2
Best matches:
  minimization.input.file_name
  minimization.input.label
</code></pre>

<p>The user can cut-and-paste the desired parameter into the command
line for another trial to run the application.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">extract: conversion of Phil objects to Python objects</h3>


<p>The Phil parser produces objects that preserve most information
generated in the parsing process, such as line numbers and parameter
attributes. While this information is very useful for pretty printing
(e.g. to archive the working parameters) and the automatic generation
of graphical user interfaces, it is only a burden in the context of
core algorithms. Therefore Phil supports "extraction" of light-weight
Python objects from the Phil objects. Based on the example above,
this can be achieved with just one line:</p>

<pre class="bg-code-DL"><code>working_params = working_phil.extract()
</code></pre>

<p>We can now use the extracted objects in the context of Python:</p>

<pre class="bg-code-DL"><code>print working_params.minimization.input.file_name
print working_params.minimization.input.label
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>experiment.dat
set2
</code></pre>

<p>'file_name' and 'label' are now a simple Python strings.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">format: conversion of Python objects to Phil objects</h3>

<p>Phil also supports the reverse conversion compared to the
previous section, from Python objects to Phil objects. For
example, to change the label:</p>

<pre class="bg-code-DL"><code>working_params.minimization.input.label = "set3"
modified_phil = master_phil.format(python_object=working_params)
modified_phil.show()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>minimization.input {
  file_name = "experiment.dat"
  label = "set3"
}
</code></pre>

We need to bring in <code>master_phil</code> again because all the meta
information was lost in the <code>working_phil.extract()</code> step that
produced <code>working_params</code>. A type-specific converter is used to
produce a string for each Python object (see the Extending Phil
section below).

<!----------------------------------------------------------------------------->

<h3 class="mt-4">.multiple = True</h3>

<p>Both <code>phil.definition</code> and <code>phil.scope</code> support the <code>.multiple = True</code> attribute. For the sake of simplicity, in the following
"multiple definition" and "multiple scope" means a master definition or
scope with <code>.multiple = True</code>. Please note the distinction between
this and multiple *values* given in a user file. For example, this
is a multiple definition in a master file:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  minimization.input {
    file_name = None
      .type = path
      .multiple = True
  }
  """)
</code></pre>

<p>And these are multiple values for this definition in a user file:</p>

<pre class="bg-code-DL"><code>user_phil = parse("""
  minimization.input {
    file_name = experiment1.dat
    file_name = experiment2.dat
    file_name = experiment3.dat
  }
  """)
</code></pre>

<p>I.e. multiple values are simply specified by repeated definitions.
Without the <code>.multiple = True</code> in the master file, <code>.fetch()</code>
retains only the *last* definition found in the master and all user
files or command-line arguments. <code>.multiple = True</code> directs Phil
to keep all values. <code>.extract()</code> then returns a list of all these
values converted to Python objects. For example, given the user
file above:</p>

<pre class="bg-code-DL"><code>working_params = master_phil.fetch(source=user_phil).extract()
print working_params.minimization.input.file_name
</code></pre>

<p>will show this Python list:</p>

<pre class="CodeGreen"><code>['experiment1.dat', 'experiment2.dat', 'experiment3.dat']
</code></pre>

<p>Multiple scopes work similarly, for example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  minimization {
    input
      .multiple = True
    {
      file_name = None
        .type = path
      label = None
        .type = str
    }
  }
  """)
</code></pre>

<p>A corresponding user file may look this this:</p>

<pre class="bg-code-DL"><code>user_phil = parse("""
  minimization {
    input {
      file_name = experiment1.dat
      label = set2
    }
    input {
      file_name = experiment2.dat
      label = set1
    }
  }
  """)
</code></pre>

<p>The result of the usual fetch-extract sequence is:</p>

<pre class="bg-code-DL"><code>working_params = master_phil.fetch(source=user_phil).extract()
for input in working_params.minimization.input:
  print input.file_name
  print input.label
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>experiment1.dat
set2
experiment2.dat
set1
</code></pre>

<p>Definitions and scopes may be nested with any combination of
<code>.multiple = False</code> or <code>.multiple = True</code>. For example, this would be a plausible master file:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  minimization {
    input
      .multiple = True
    {
      file_name = None
        .type = path
      label = None
        .type = str
        .multiple = True
    }
  }
  """)
</code></pre>

<p>This is a possible corresponding user file:</p>

<pre class="bg-code-DL"><code>user_phil = parse("""
  minimization {
    input {
      file_name = experiment1.dat
      label = set1
      label = set2
      label = set3
    }
    input {
      file_name = experiment2.dat
      label = set2
      label = set3
    }
  }
  """)
</code></pre>

<p>The fetch-extract sequence is the same as before:</p>

<pre class="bg-code-DL"><code>working_params = master_phil.fetch(source=user_phil).extract()
  for input in working_params.minimization.input:
    print input.file_name
    print input.label
</code></pre>

<p>but the output shows lists of strings for <code>label</code> instead of just
one Python string:</p>

<pre class="CodeGreen"><code>experiment1.dat
['set1', 'set2', 'set3']
experiment2.dat
['set2', 'set3']
</code></pre>


<!----------------------------------------------------------------------------->

<h3 class="mt-4">fetch_diff: difference between master_phil and working_phil</h3>

<p>The <code>.fetch()</code> method introduced above produces a complete copy
of the Phil master with all user definitions and scopes merged in.
If the Phil master is large, the output of <code>working_phil.show()</code> will
therefore also be large. It may be difficult to see which definitions
still have default values, and which definitions are changed.
To get just the difference between the master and the working
Phil objects, the <code>.fetch_diff()</code> method is available. For example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  minimization.parameters {
    method = *bfgs conjugate_gradient
      .type = choice
    max_iterations = 10
      .type = int
  }
  """)

user_phil = parse("""
  minimization.parameters {
    method = bfgs *conjugate_gradient
  }
  """)

working_phil = master_phil.fetch(source=user_phil)
diff_phil = master_phil.fetch_diff(source=working_phil)
diff_phil.show()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>minimization.parameters {
  method = bfgs *conjugate_gradient
}
</code></pre>

Here the minimization method was changed from 'bfgs'
to 'conjugate_gradient' but the number of iterations is
unchanged. Therefore the latter does not appear in the output.
<code>.fetch_diff()</code> is completely general and works for any combination
of definitions and scopes with <code>.multiple = False</code> or <code>.multiple
= True</code>.

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Includes</h3>

<p>Phil also supports merging of files at the parsing level. For example:</p>

<pre class="bg-code-DL"><code>include file general.params

minimization.parameters {
  include file specific.params
}
</code></pre>

<p>Another option for building master files from a library of building
blocks is based on Python's import mechanism. For example:</p>

<pre class="bg-code-DL"><code>include file general.params

minimization.parameters {
  include scope app.module.master_phil
}
</code></pre>

<p>When encountering the <code>include scope</code>, the Phil parser automatically
imports <code>app.module</code> (equivalent to <code>import app.module</code> in a Python
script). The <code>master_phil</code> object in the imported module must be
a pre-parsed Phil scope or a plain Phil string. The content of the
<code>master_phil</code> scope is inserted into the scope of the <code>include
scope</code> statement.</p>

<p><code>include</code> directives enable hierarchical building of
master files without the need to copy-and-paste large fragments
explicitly. Duplication appears only in automatically generated user
files. I.e. the programmer is well served because a system of master
files can be kept free of large-scale redundancies that are difficult
to maintain. At the same time the end user is well served because
the indirections are resolved automatically and all parameters are
presented in one uniform view.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Variable substitution</h3>

<p>Phil supports variable substitution using $var and $(var)
syntax. A few examples say more than many words:</p>

<pre class="bg-code-DL"><code>var_phil = parse("""
  root_name = peak
  file_name = $root_name.mtz
  full_path = $HOME/$file_name
  related_file_name = $(root_name)_data.mtz
  message = "Reading $file_name"
  as_is = ' $file_name '
  """)
var_phil.fetch(source=var_phil).show()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>root_name = peak
file_name = "peak.mtz"
full_path = "/net/cci/rwgk/peak.mtz"
related_file_name = "peak_data.mtz"
message = "Reading peak.mtz"
as_is = ' $file_name '
</code></pre>

<p>Note that the variable substitution does not happen during parsing.
The output of <code>params.show()</code> is identical to the input. In the
example above, variables are substituted by the <code>.fetch()</code> method
that we introduced earlier to merge user files given a master file.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Extending Phil</h3>

<p>Phil comes with a number of predefined converters used by <code>.extract()</code> and <code>.format()</code> to convert to and from pure Python objects. These
are:</p>

<pre class="CodeGreen"><code>.type =
  words     retains the "words" produced by the parser
  strings   list of Python strings (also used for .type = None)
  str       combines all words into one string
  path      path name (same as str_converters)
  key       database key (same as str_converters)
  bool      Python bool
  int       Python int
  float     Python float
  choice    string selected from a pre-defined list
</code></pre>

<p>It is possible to extend Phil with user-defined converters.
For example:</p>

<pre class="bg-code-DL"><code>import libtbx.phil
from libtbx.phil import tokenizer

class upper_converters:

  phil_type = "upper"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    s = libtbx.phil.str_from_words(words=words)
    if (s is None): return None
    return s.upper()

  def as_words(self, python_object, master):
    if (python_object is None):
      return [tokenizer.word(value="None")]
    return [tokenizer.word(value=python_object.upper())]

converter_registry = libtbx.phil.extended_converter_registry(
  additional_converters=[upper_converters])
</code></pre>

<p>The extended <code>converter_registry</code> is passed as an additional
argument to Phil's <code>parse</code> function:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  value = None
    .type = upper
  """,
    converter_registry=converter_registry)
user_phil = parse("value = extracted")
working_params = master_phil.fetch(source=user_phil).extract()
print(working_params.value)
</code></pre>

<p>The <code>print</code> statement at the end writes "EXTRACTED". It also goes
the other way, starting with a lower-case Python value:</p>

<pre class="bg-code-DL"><code>working_params.value = "formatted"
working_phil = master_phil.format(python_object=working_params)
working_phil.show()
</code></pre>

<p>The output of the <code>.show()</code> call is "value = FORMATTED".</p>

<p>Arbitrary new types can be added to Phil by defining similar
converters. If desired, the pre-defined converters for the basic
types can even be replaced. All converters have to have <code>__str__()</code>,
<code>from_words()</code> and <code>as_words()</code> methods. More complex converters may optionally have a non-trivial <code>__init__()</code> method (an example
is the <code>choice_converters</code> class in <code>libtbx/phil/__init__.py</code>).</p>

<p>Additional domain-specific converters are best defined in a separate
module, along with a corresponding parse() function using the
extended converter registry as the default. See, for example,
<code>iotbx/phil.py</code> in the same <code>cctbx</code> project that also hosts <code>libtbx</code>.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Details</h3>

<!----------------------------------------------------------------------------->

<h4>.type = ints and .type = floats</h4>

<p>The built-in <code>ints</code> and <code>floats</code> converters handle lists of integer and floating point numbers, respectively. For example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  random_integers = None
    .type = ints
  euler_angles = None
    .type = floats(size=3)
  unit_cell_parameters = None
    .type = floats(size_min=1, size_max=6)
  rotation_part = None
    .type = ints(size=9, value_min=-1, value_max=1)
  """)

user_phil = parse("""
  random_integers = 3 18 5
  euler_angles = 10 -20 30
  unit_cell_parameters = 10,20,30
  rotation_part = "1,0,0;0,-1,0;0,0,-1"
  """)

working_phil = master_phil.fetch(source=user_phil)
working_phil.show()
print
working_params = working_phil.extract()
print working_params.random_integers
print working_params.euler_angles
print working_params.unit_cell_parameters
print working_params.rotation_part
print
working_phil = master_phil.format(python_object=working_params)
working_phil.show()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>random_integers = 3 18 5
euler_angles = 10 -20 30
unit_cell_parameters = 10,20,30
rotation_part = "1,0,0;0,-1,0;0,0,-1"

[3, 18, 5]
[10.0, -20.0, 30.0]
[10.0, 20.0, 30.0]
[1, 0, 0, 0, -1, 0, 0, 0, -1]

random_integers = 3 18 5
euler_angles = 10 -20 30
unit_cell_parameters = 10 20 30
rotation_part = 1 0 0 0 -1 0 0 0 -1
</code></pre>

<p>The list of <code>random_integers</code> can have arbitrary size and arbitrary values.</p>

<p>For <code>euler_angles</code>, exactly three values must be given.</p>

<p>For <code>unit_cell_parameters</code>, one to six values are acceptable.</p>

<p>The list of values for <code>rotation_part</code> must have nine integer
elements, with values {-1,0,1}.</p>

<p>All keywords are optional and can be used in any combination, except if
<code>size</code> is given, <code>size_min</code> and <code>size_max</code> cannot also be given.</p>

<p>Lists of values can optionally use commas or semicolons as separators
between values. In this context, both characters are equivalent to
a white-space. <code>.format()</code> always uses spaces as separators, i.e.
commas and semicolons are not preserved in an <code>.extract()</code>-<code>.format()</code> cycle. (Note that lists using semicolons as separators must be quoted; see the "Semicolon syntax" section below.)</p>

<!----------------------------------------------------------------------------->

<h4>.type = choice</h4>

<p>The built-in <code>choice</code> converters support single and multi choices.
Here are two examples, a single choice <code>gender</code> and a multi choice
<code>favorite_sweets</code>:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  gender = male female
    .type = choice
  favorite_sweets = ice_cream chocolate candy_cane cookies
    .type = choice(multi=True)
  """)

jims_choices = parse("""
  gender = *male female
  favorite_sweets = *ice_cream chocolate candy_cane *cookies
  """)

jims_phil = master_phil.fetch(source=jims_choices)
jims_phil.show()
jims_params = jims_phil.extract()
print jims_params.gender, jims_params.favorite_sweets
</code></pre>

<p>Selected items are marked with a star '*'. The <code>.extract()</code>
method returns either a string with the selected value (single choice)
or a list of strings with all selected values (multi choice). The
output of the example is:</p>

<pre class="bg-code-DL"><code>gender = *male female
favorite_sweets = *ice_cream chocolate candy_cane *cookies
male ['ice_cream', 'cookies']
</code></pre>

<p>To maximize convenience, especially for choices specified via the
command-line, the '*' is optional if only one value is given.
For example, the following two definitions are equivalent:</p>

<pre class="bg-code-DL"><code>gender = female
gender = male *female
</code></pre>

<p>If the <code>.optional</code> attribute is not defined, it defaults to <code>True</code> and this is possible:</p>

<pre class="bg-code-DL"><code>ignorant_choices = parse("""
  gender = male female
  favorite_sweets = ice_cream chocolate candy_cane cookies
  """)

ignorant_params = master_phil.fetch(source=ignorant_choices).extract()
print ignorant_params.gender, ignorant_params.favorite_sweets
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>None []
</code></pre>

In this case the application has to deal with the <code>None</code> and
the empty list. If <code>.optional = False</code>, <code>.extract()</code> will lead to informative error messages. The application will never receive
<code>None</code> or an empty list.

<p>If a value in the user file is not a possible choice, <code>.extract()</code>
leads to an error message listing all possible choices, for example:</p>

<pre class="CodeGreen"><code>Sorry: Not a possible choice for favorite_sweets: icecream
  Possible choices are:
    ice_cream
    chocolate
    candy_cane
    cookies
</code></pre>

<p>This message is designed to aid users in recovering from mis-spelled
choices typed in at the command-line. Command-line choices are
further supported by this syntax:</p>

<pre class="bg-code-DL"><code>greedy_choices = parse("""
  favorite_sweets=ice_cream+chocolate+cookies
  """)

greedy_params = master_phil.fetch(source=greedy_choices).extract()
print greedy_params.favorite_sweets
</code></pre>

<p>Ouput:</p>

<pre class="CodeGreen"><code>['ice_cream', 'chocolate', 'cookies']
</code></pre>

<p>Finally, if the <code>.optional</code> attribute is not specified or <code>True</code>, <code>None</code> can be assigned:</p>

<pre class="bg-code-DL"><code>no_thanks_choices = parse("""
  favorite_sweets=None
  """)

no_thanks_params = master_phil.fetch(source=no_thanks_choices).extract()
print no_thanks_params.favorite_sweets
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>[]
</code></pre>

<!----------------------------------------------------------------------------->

<h4>scope_extract</h4>

<p>The result of <code>scope.extract()</code> is a <code>scope_extract</code> instance with attributes corresponding to the embedded definitions and
sub-scopes. For example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  minimization.input {
    file_name = None
      .type = path
  }
  minimization.parameters {
    max_iterations = 10
      .type = int
  }
  """)

user_phil = parse("""
  minimization.input.file_name = experiment.dat
  minimization.parameters.max_iterations = 5
  """)

working_params = master_phil.fetch(source=user_phil).extract()
print working_params
print working_params.minimization.input.file_name
print working_params.minimization.parameters.max_iterations
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>&lt;libtbx.phil.scope_extract object at 0x2ad50bae7550&mt;
experiment.dat
5
</code></pre>

<p>This just repeats what was shown several times before, but
<code>scope_extract</code> includes a few additional, special features that are
worth knowing. The first special feature is the <code>.__phil_path__()</code>
method:</p>

<pre class="bg-code-DL"><code>print working_params.minimization.input.__phil_path__()
print working_params.minimization.parameters.__phil_path__()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>minimization.input
minimization.parameters
</code></pre>

<p>This feature is most useful for formatting informative error messages
without having to hard-wire the fully-qualified parameter names. Use
<code>.__phil_path__()</code> to ensure that the names are automatically
correct even if the master file is changed in major ways. Note that the
<code>.__phil_path__()</code> method is available only for extracted scopes,
not for extracted definitions since it would be very cumbersome to
implement. However, the fully-qualified name of a definition can
be obtained via <code>.__phil_path__(object_name="max_iterations")</code>;
usually the <code>object_name</code> is readily available in the contexts in
which the fully-qualified name is needed. There is also
<code>.__phil_path_and_value__(object_name)</code> which returns a 2-tuple
of the fully-qualified path and the extracted value, ready to
be used for formatting error messages.</p>

<p>The next important feature is a safety guard: assignment to a
non-existing attribute leads to an exception. For example,
if the attribute is mis-spelled:</p>

<pre class="bg-code-DL"><code>working_params.minimization.input.filename = "other.dat"
</code></pre>

<p>Result:</p>

<pre class="CodeGreen"><code>AttributeError: Assignment to non-existing attribute "minimization.input.filename"
  Please correct the attribute name, or to create
  a new attribute use: obj.__inject__(name, value)
</code></pre>

<p>In addition to trivial spelling errors, the safety guard traps
overlooked dependencies related to changes in the master file.</p>

<p>In some (unusual) situations it may be useful to attach attributes to
an extracted scope that have no correspondence in the master file.
Use the <code>.__inject__(name, value)</code> method for this purpose to
by-pass the safety-guard. As a side-effect of this design, injected
attributes are easily pin-pointed in the source code (simply search
for <code>__inject__)</code>, which can be a big help in maintaining a large
code base.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Multiple definitions and scopes</h3>

<p>All Phil attributes of multiple definitions or scopes are determined
by the first occurrence in the master file. All following instances in
the master file are defaults. Any instances in user files (merged via
<code>.fetch()</code>) are added to the default instances in the master file.
For example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  plot
    .multiple = True
  {
    style = line bar pie_chart
      .type=choice
    title = None
      .type = str
  }
  plot {
    style = line
    title = Line plot (default in master)
  }
  """)

user_phil = parse("""
  plot {
    style = bar
    title = Bar plot (provided by user)
  }
  """)

working_phil = master_phil.fetch(source=user_phil)
working_phil.show()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>plot {
  style = *line bar pie_chart
  title = Line plot (default in master)
}
plot {
  style = line *bar pie_chart
  title = Bar plot (provided by user)
}
</code></pre>

<p><code>.extract()</code> will produce a list with two elements:</p>

<pre class="bg-code-DL"><code>working_params = working_phil.extract()
print working_params.plot
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>[&lt;libtbx.phil.scope_extract object at 0x2b1ccb5b1910&mt;,
 &lt;libtbx.phil.scope_extract object at 0x2b1ccb5b1c10&mt;]
</code></pre>

<p>Note that the first (i.e. master) occurrence of the scope is not
extracted. In practice this is usually the desired behavior, but it
can be changed by setting the <code>plot</code> scope attribute <code>.optional
= False</code>. For example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  plot
    .multiple = True
    .optional = False
  {
    style = line bar pie_chart
      .type=choice
    title = None
      .type = str
  }
  plot {
    style = line
    title = Line plot (default in master)
  }
  """)
</code></pre>

<p>With the <code>user_phil</code> as before, <code>.show()</code> and <code>.extract()</code> now produce three entries each:</p>

<pre class="bg-code-DL"><code>working_phil = master_phil.fetch(source=user_phil)
working_phil.show()
print working_phil.extract().plot
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>plot {
  style = line bar pie_chart
  title = None
}
plot {
  style = *line bar pie_chart
  title = Line plot (default in master)
}
plot {
  style = line *bar pie_chart
  title = Bar plot (provided by user)
}
[&lt;libtbx.phil.scope_extract object at 0x2af4c307bcd0&mt;,
 &lt;libtbx.phil.scope_extract object at 0x2af4c307bd50&mt;,
 &lt;libtbx.phil.scope_extract object at 0x2af4c307be10&mt;]
</code></pre>

<p>With <code>.optional = True</code>, the master of a multiple definition or
scope is *never* extracted. With <code>.optional = False</code>, it is *always*
extracted, and always first in the list.</p>

<p>The "always first in the list" rule for multiple master objects is
special. Other instances of multiple scopes are shown and extracted
in the order in which they appear in the master file and the merged
user file(s), with all *exact* duplicates removed. If duplicates are
detected, the earlier copy is removed, unless it is the master.</p>

<p>These rules are designed to produce easily predictable results in
situations where multiple Phil files are merged (via <code>.fetch()</code>),
including complete copies of the master file.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">fetch option: track_unused_definitions</h3>

<p>The default behavior of <code>.fetch()</code> is to simply ignore user
definitions that don't match anything in the master file. It it is
possible to request a complete list of all user definitions ignored by
<code>.fetch()</code>. For example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  input {
    file_name = None
      .type = path
  }
  """)

user_phil = parse("""
  input {
    file_name = experiment.dat
    label = set1
    lable = set2
  }
  """)

working_phil, unused = master_phil.fetch(
  source=user_phil, track_unused_definitions=True)
working_phil.show()
for object_locator in unused:
  print "unused:", object_locator
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>input {
  file_name = experiment.dat
}
unused: input.label (input line 4)
unused: input.lable (input line 5)
</code></pre>

<p>To catch spelling errors, or to alert users to changes in the master
file, it is good practice to set <code>track_unused_definitions=True</code>
and to show warnings or errors.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Semicolon syntax</h3>

<p>In all the examples above, line breaks act as syntactical elements
delineating the end of definitions. This is most obvious, but for
convenience, Phil also supports using the semicolon ';' instead.
For example:</p>

<pre class="bg-code-DL"><code>phil_scope = parse("""
   quick .multiple=true;.optional=false{and=very;.type=str;dirty=use only on command-lines, please!;.type=str}
   """)

phil_scope.show(attributes_level=2)
</code></pre>

<p>Clearly, the output looks much nicer:</p>

<pre class="CodeGreen"><code>quick
  .optional = False
  .multiple = True
{
  and = very
    .type = str
  dirty = use only on command-lines, please!
    .type = str
}
</code></pre>

<p>Master files generally shouldn't make use of the semicolon syntax, even
though it is possible. In user files it is more acceptable, but the main
purpose is to support passing parameters from the command line.</p>

<p>Note that the Phil output methods (<code>.show()</code>, <code>.as_str()</code>) never make use of the semicolon syntax.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Phil comments</h3>

<p>Phil supports two types of comments:</p>

<ul>
  <li>
     Simple one-line comments starting with a hash '#'.
    All following characters through the end of the line are ignored.
  </li>
  <li>
    Syntax-aware comments starting with an exclamation mark '!'.
  </li>
</ul>

<p>The exclamation mark can be used to easily comment out entire
syntactical constructs, for example a complete scope including all
attributes:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  !input {
    file_name = None
      .type = path
      .multiple = True
  }
  """)
master_phil.show()
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>!input {
  file_name = None
}
</code></pre>

<p>As is evident from the output, Phil keeps the content "in mind",
but the scope is not actually used by <code>.fetch()</code>:</p>

<pre class="bg-code-DL"><code>user_phil = parse("""
  input.file_name = experiment.dat
  """)
print len(master_phil.fetch(source=user_phil).as_str())
</code></pre>

<p>Output:</p>

<pre class="CodeGreen"><code>0
</code></pre>

<p>I.e. the <code>.fetch()</code> method ignored the user definition because the
corresponding master is commented out.</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">Quotes and backslash</h3>

<p>Similar to Python, Phil supports single quotes, double quotes,
and triple quotes (three single or three double quotes). Unlike
Python, quotes can often be omitted, and single quotes and double
quotes have different semantics, similar to that of Unix shells:
'$' variables are expanded if embedded in double quotes, but not
if embedded in single quotes. See the variable substitution section
above for examples.</p>

<p>The backslash can be used in the usual way (Python, Unix shells) to
"escape" line breaks, quotes, and a second backslash.</p>

<p>For convenience, a line starting with quotes is automatically treated
as a continuation of a definition on the previous line(s). The trailing
backslash on the previous line may be omitted.</p>

<p>The exact rules for quoting and backslash escapes are intricate.
A significant effort was made to mimic the familiar behavior of Python
and Unix shells where possible, but nested constructs of quotes and
backslashes are still prone to cause surprises. In unusual situations,
probably the fastest method to obtain the desired result is trial
and error (as opposed to studying the intricate rules).</p>

<!----------------------------------------------------------------------------->

<h3 class="mt-4">scope.show(attributes_level=3)</h3>

<p>In this document, the <code>scope.show()</code> method is used extensively
in the examples. With the defaults for the method parameters, it
only shows the Phil scope or definition names and and associated
values. It is also possible to include some or all Phil scope or
definition attributes in the <code>.show()</code> output, as directed by the
<code>attributes_level</code> parameter:</p>

<pre class="CodeGreen"><code>attributes_level=0: shows only names and values
                 1: also shows the .help attribute
                 2: shows all attributes which are not None
                 3: shows all attributes
</code></pre>

<p><code>scope.show(attributes_level=2)</code> can be used to pretty-print
master files without any loss of information. <code>attributes_level=3</code>
is useful to obtain a full listing of all available attributes,
but all information is preserved with the usually much less verbose
<code>attributes_level=2</code>. This is illustrated by the following example:</p>

<pre class="bg-code-DL"><code>master_phil = parse("""
  minimization {
    input
      .help = "File names and data labels."
      .multiple = True
    {
      file_name = None
        .type = path
      label = None
        .help = "A unique substring of the data label is sufficient."
        .type = str
    }
  }
  """)

for attributes_level in range(4):
  master_phil.show(attributes_level=attributes_level)
</code></pre>

<p>Output with <code>attributes_level=0</code> (the default):</p>

<pre class="CodeGreen"><code>minimization {
  input {
    file_name = None
    label = None
  }
}
</code></pre>

<p>Output with <code>attributes_level=1</code>:</p>

<pre class="CodeGreen"><code>minimization {
  input
    .help = "File names and data labels."
  {
    file_name = None
    label = None
      .help = "A unique substring of the data label is sufficient."
  }
}
</code></pre>

<p>Output with <code>attributes_level=2</code>:</p>

<pre class="CodeGreen"><code>minimization {
  input
    .help = "File names and data labels."
    .multiple = True
  {
    file_name = None
      .type = path
    label = None
      .help = "A unique substring of the data label is sufficient."
      .type = str
  }
}
</code></pre>

<p>Output with <code>attributes_level=3</code>:</p>

<pre class="CodeGreen"><code>minimization
  .style = None
  .help = None
  .caption = None
  .short_caption = None
  .optional = None
  .call = None
  .multiple = None
  .sequential_format = None
  .disable_add = None
  .disable_delete = None
  .expert_level = None
{
  input
    .style = None
    .help = "File names and data labels."
    .caption = None
    .short_caption = None
    .optional = None
    .call = None
    .multiple = True
    .sequential_format = None
    .disable_add = None
    .disable_delete = None
    .expert_level = None
  {
    file_name = None
      .help = None
      .caption = None
      .short_caption = None
      .optional = None
      .type = path
      .multiple = None
      .input_size = None
      .expert_level = None
    label = None
      .help = "A unique substring of the data label is sufficient."
      .caption = None
      .short_caption = None
      .optional = None
      .type = str
      .multiple = None
      .input_size = None
      .expert_level = None
  }
}
</code></pre>

<!----------------------------------------------------------------------------->

<!----------------------- EDIT END ---------------------------->
<!-- DO NOT EDIT ANYTHING BELOW!!!! -->
</div> <!-- end col-sm-9 -->

<!-- automatic table of contents
     located in the sidebar; will move to the top on a small screen -->
<div class="col-sm-3 mt-5">
  <nav id="toc" data-toggle="toc"></nav>
</div> <!-- end col-sm-3 -->


{% endblock %}
